#pragma once
#include <ranges>

#include "native.h"
#include <asio.hpp>
#include <asio/experimental/awaitable_operators.hpp>
using namespace asio::experimental::awaitable_operators;

#include <spdlog/spdlog.h>

#include "utils.hpp"
#include "route.hpp"
#include "parser.hpp"
#include "pt.hpp"
#include "auth.hpp"
#include "evm.hpp"
#include "file.hpp"
#include "version.hpp"
#include "loader.hpp"

namespace dcn
{
    /**
     * @brief Helper function to set CORS headers for the response.
     */
    void setCORSHeaders(const http::Request & request, http::Response& response);

    /**
     * @brief Helper function to handle authentication.
     */
    asio::awaitable<std::expected<evm::Address, auth::AuthError>> authenticate(const http::Request & request, const auth::AuthManager & auth_manager);

    /**
     * @brief Handles GET requests for the version endpoint.
     */
    asio::awaitable<http::Response> GET_version(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, const std::string & build_timestamp);

    /**
     * @brief Handles HEAD requests for a file by returning a response with CORS headers.
     */
    asio::awaitable<http::Response> HEAD_serveFile(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);

    /**
     * @brief Handles OPTIONS requests for a file by returning a response with CORS headers.
     */
    asio::awaitable<http::Response> OPTIONS_serveFile(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);

    /**
     * @brief Handles GET requests for a file.
     */
    asio::awaitable<http::Response> GET_serveFile(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, const std::string mime_type, const std::string & file_content);

    /**
     * @brief Handles GET requests for a binary file.
     */
    asio::awaitable<http::Response> GET_serveBinaryFile(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, const std::string mime_type, const std::vector<std::byte> & file_content);


    /**
     * @brief Handle a GET request to /auth/nonce
     *
     * The url must be in the following format:
     * 
     * - /auth/nonce/<nonce>
     *
     * The response body will be a json string with the following format:
     *
     * {
     *     "nonce": "<nonce>"
     * }
     *
     * Where `<nonce>` is the generated nonce.
     */
    asio::awaitable<http::Response> GET_nonce(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, auth::AuthManager &);


    asio::awaitable<http::Response> OPTIONS_auth(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);
    /**
     * @brief Handles a POST request to /auth
     * 
     * The url must be in the following format:
     *  
     * - /auth
     * 
     * The request body must be a json string in format
     * 
     * {
     *      "address": "<address>",
     *      "signature": "<signature>",
     *      "message": "<message>"
     * }
     * 
     * Where `<address>` is the address of the user who is trying to authenticate, `<signature>` is the signature of the message by the user, and `<message>` is the nonce generated by the server.
     * 
     * The response body will be a json string in format
     * 
     * {
     *      "success": "true/false",
     * }
     * 
     * @param request The request object
     * @param args The arguments of the request
     * @param auth_manager The authentication manager
     * @return http::Response The response object
     */
    asio::awaitable<http::Response> POST_auth(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, auth::AuthManager &);


    asio::awaitable<http::Response> OPTIONS_refresh(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);
    /**
     * @brief Handles a POST request to /auth/refresh
     * 
     * The url must be in the following format:
     * 
     * - /auth/refresh
     * 
     * The request body must be a json string in format
     * 
     * {
     *      "refresh_token": "<refresh_token>"
     * }
     * 
     * Where `<refresh_token>` is the refresh token of the user who is trying to refresh their access token.
     * 
     * The response body will be a json string in format
     * 
     * {
     *      "success": "true/false"
     * }
     * 
     * @param request The request object
     * @param args The arguments of the request
     * @param auth_manager The authentication manager
     * @return http::Response The response object
     */
    asio::awaitable<http::Response> POST_refresh(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, auth::AuthManager &);


    asio::awaitable<http::Response> OPTIONS_accountInfo(const http::Request & request, std::vector<server::RouteArg>, server::QueryArgsList);
    asio::awaitable<http::Response> GET_accountInfo(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, registry::Registry & registry);

    /**
     * @brief Handles HEAD requests for the feature endpoint.
     *
     * @param request The incoming HTTP request
     * @param routeArgs Route arguments
     * @param registry Registry instance for retrieving features
     * @return An HTTP response with CORS headers
    */
    asio::awaitable<http::Response> HEAD_feature(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, registry::Registry & registry);
    /**
     * @brief Handles OPTIONS requests by returning a response with CORS headers.
     *
     * @param request The incoming HTTP request (not used in this implementation)
     * @param routeArgs Route arguments (not used in this implementation)
     * @return An HTTP response with CORS headers
     */
    asio::awaitable<http::Response> OPTIONS_feature(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);

    /**
     * @brief Returns the newest feature by name or a specific feature by name and id
     *        if the id is provided in the url.
     *
     * The url must be in one of the following formats:
     *
     * - /features/<feature_name>
     * 
     * - /features/<feature_name>/<feature_id>
     */
    asio::awaitable<http::Response> GET_feature(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, registry::Registry & registry, evm::EVM & evm);

    /**
     * @brief Handle a POST request to /features
     *
     * The url must be in the following format:
     * 
     * - /features
     *
     * The request body must be a json string representing a `hm::Feature` object.
     *
     * The response body will be a json string with the following format:
     *
     * {
     *     "name": "<name>",
     *     "version": "<version>"
     * }
     *
     * Where `<name>` is the name of the feature and `<version>` is the hash of the feature.
     */
    asio::awaitable<http::Response> POST_feature(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, auth::AuthManager & auth_manager, registry::Registry & registry, evm::EVM & evm);


    /**
     * @brief Handles HEAD requests for the transformation endpoint.
     *
     * @param request The incoming HTTP request
     * @param routeArgs Route arguments
     * @param registry Registry instance for retrieving transformations
     * @return An HTTP response with CORS headers for the transformation endpoint
     */
    asio::awaitable<http::Response> HEAD_transformation(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList, registry::Registry & registry);

    /**
     * @brief Handles OPTIONS requests for the transformation endpoint by returning a response with CORS headers.
     *
     * @param request The incoming HTTP request (not used in this implementation)
     * @param routeArgs Route arguments (not used in this implementation)
     * @return An HTTP response with CORS headers for the transformation endpoint
     */
    asio::awaitable<http::Response> OPTIONS_transformation(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);

    /**
     * @brief Handles GET requests for the transformation endpoint.
     *
     * Retrieves a transformation by name and optional ID, and returns it as JSON.
     *
     * @param request The incoming HTTP request
     * @param args Route arguments (transformation name and optional ID)
     * @param registry Registry instance for retrieving transformations
     * @return An HTTP response with the transformation data as JSON, or an error response if invalid input or not found
     */
    asio::awaitable<http::Response> GET_transformation(const http::Request &, std::vector<server::RouteArg> args, server::QueryArgsList, registry::Registry & registry, evm::EVM & evm);

    /**
     * @brief Handles POST requests for the transformation endpoint.
     *
     * Verifies the access token in the cookie header, then adds a new transformation to the registry.
     *
     * @param request The incoming HTTP request with the transformation data in the body
     * @param args Route arguments (not used in this implementation)
     * @param auth_manager Authentication manager instance for verifying access tokens
     * @param registry Registry instance for adding transformations
     * @return An HTTP response with the added transformation data as JSON, or an error response if invalid input or authentication failure
     */
    asio::awaitable<http::Response> POST_transformation(const http::Request &, std::vector<server::RouteArg> args, server::QueryArgsList, auth::AuthManager & auth_manager, registry::Registry & registry, evm::EVM & evm);


    //asio::awaitable<http::Response> GET_condition(const http::Request &, std::vector<RouteArg>);

    //asio::awaitable<http::Response> POST_condition(const http::Request &);

    asio::awaitable<http::Response> OPTIONS_execute(const http::Request &, std::vector<server::RouteArg>, server::QueryArgsList);
    asio::awaitable<http::Response> GET_execute(const http::Request & request, std::vector<server::RouteArg> args, server::QueryArgsList, const auth::AuthManager & auth_manager, const registry::Registry & registry, evm::EVM & evm);
}